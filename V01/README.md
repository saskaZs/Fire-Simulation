# ðŸ”¥ 2D Fire Simulation with React and Canvas

A realistic, interactive 2D fire simulation built with React and native HTML Canvas. This educational project demonstrates a particle system for rendering dynamic fire effects in a browser, with physics, color transitions, and a simple glow effectâ€”all without external 3D libraries.

The fire's "energy" is adjustable via a slider, influencing spawn rates, velocity, spread, and lifetime to create a natural, flickering flameâ€”from dim embers to a roaring blaze.

---

## ðŸš€ Features

- **Particle System:** Up to hundreds of particles with position, velocity, lifetime, and color attributes.
- **Gaussian Distribution:** For natural spawning (tight jet at high energy, wide base at low).
- **Physics Simulation:** Buoyancy, turbulence, air drag, and random bursts for realistic motion.
- **Color Fading:** Particles transition from white/hot to red/ember based on lifetime and energy.
- **Canvas Rendering:** Radial gradients for soft particles, translucent clears for trails, and optional bloom-like glow.
- **Interactive Controls:** Energy slider (10â€“100%) for real-time adjustments.
- **Pure JS/React:** No dependencies beyond React; everything in hooks and canvas 2D context.

---

## ðŸ“‚ Project Structure

`index.html`                  # Vite HTML entry point (sets up the root div and loads the app) <br>
`eslint.config.js`            # ESLint configuration for code linting and best practices <br>
`package.json`                # Project metadata, dependencies, and npm scripts <br>
`package-lock.json`           # Exact dependency versions (generated by npm) <br>

`main.jsx`                # Entry point for React: renders <App /> into #root <br>
`App.jsx`                 # Root component: simply renders the FireSimulation <br>
`index.css`             # Global styles for layout, canvas, and controls <br>

`FireSimulation.jsx`  # Main UI: Canvas element, energy slider, and animation hook integration <br>

`useFireAnimations.js` # Custom hook for the animation loop: spawning, physics, drawing <br>

`gaussian.js`        # Gaussian (normal) random number generator using Box-Muller transform <br>
`colors.js`           # Utility to compute particle color as RGBA based on lifetime and energy <br>
`createParticle.js`   # Factory function for new particles with energy-based parameters <br>


---

## ðŸ§  Theoretical Background

This fire simulation leverages concepts from **particle systems**, **procedural animation**, **physics-based modeling**, and **probability distributions** (Gaussian). Here's a detailed explanation of the core ideas and how they contribute to a realistic flame.

### 1. Particle Systems for Fire Simulation

Fire is amorphous and dynamic, making it ideal for **particle-based rendering** rather than fixed geometry:

- Particles are emitted continuously from a base point (burner).
- Each has attributes like position, velocity, energy (lifetime), and size.
- Rendered as soft circles on a 2D canvas for efficiency.

Benefits:
- Simulates chaos and fluidity without complex meshes.
- CPU-driven for simplicity (educational focus), but scalable to GPU if needed.

In this project, particles are managed in an array, updated/drawn per frame using `requestAnimationFrame`.

### 2. Gaussian Distribution for Organic Spawning

Uniform random spawning creates unnatural shapes. Instead, positions use a **2D Gaussian (normal) distribution** centered on the burner:

$$ x \sim \mathcal{N}(\mu, \sigma^2) $$

- $\mu =$ burner center.
- $\sigma$ scales with energy: small for high-energy jets, large for low-energy bases.

Generated via **Box-Muller transform**:

$$ z_0 = \sqrt{-2 \ln u_1} \cos(2\pi u_2) $$

This clusters particles centrally for a bright core, with sparser edgesâ€”mimicking real flame density.

### 3. Physics and Forces

Particles evolve under simple forces, applied per frame (Î”t â‰ˆ 1/60s):

| Force              | Purpose                                      | Implementation Details                              |
|--------------------|----------------------------------------------|-----------------------------------------------------|
| **Initial upward velocity** | Simulates rising hot gas                     | Negative Y (up); stronger at high energy (`-1.5 - energy Ã— 4.5`) |
| **Buoyancy (acceleration)** | Sustains ascent as particles cool            | Constant upward add: `- (0.02 + energy Ã— 0.1) Ã— Î”t` |
| **Turbulence**     | Adds swirling chaos                           | Sine/cos noise: `Math.sin(frame + pos) Ã— amplitude` |
| **Air drag**       | Decelerates over time                        | Velocity Ã— `(1 - dragCoeff Ã— Î”t)`; higher drag at low energy |
| **Centripetal pull** | Keeps flame cohesive (pulls toward center)  | If far out: add inward velocity component           |
| **Random bursts**  | Creates flame "tongues"                      | Rare energy bonus to edge particles                 |

These rules yield emergent turbulence, like real convection currents.

### 4. Lifetime and Energy Dynamics

- **Initial Energy:** Higher in center (Gaussian bias); scales with global energy slider.
- **Decay:** Linear drain per frame; faster at edges for shorter peripheral particles.
- **Life Fraction:** `remaining / initial` in [0..1]; drives color, size, and fade.

This produces gradients: tall, bright cores at high energy; short, wide embers at low.

### 5. Color Progression and Rendering

Colors approximate **black-body radiation**:

- High energy: Blue/cyan tints (blowtorch).
- Mid: Yellow/orange.
- Low: Red/orange.

Computed via life fraction and energy, output as RGBA with alpha fade (`Math.pow(life, 0.7)` for smooth tails).

Rendering:
- **Translucent Clear:** `rgba(10,10,15,0.2)` fill per frame for motion trails/smoke.
- **Radial Gradients:** Opaque center to transparent edge for soft particles.
- **Glow Effect:** Extra larger/fainter circles around hot particles (simulated bloom).
- Canvas ops: `fillRect` for clear, `arc` + `createRadialGradient` for particles.

### 6. Energy Scaling and Non-Linearity

Slider (10â€“100%) uses quadratic scaling (`energyÂ²`) for intuitive feel:
- Spawn rate: 6â€“15 particles/frame.
- Forces/lifetimes ramp non-linearlyâ€”small increases yield big visual changes, like real fire.

### 7. Performance Considerations

- Fixed canvas size (800x600) for consistency.
- Particle cap implicit via spawn/decay balance.
- No GPU shadersâ€”pure 2D context for accessibility.

This mirrors techniques in games/VFX (e.g., Canvas particles in web games, similar to PixiJS but vanilla).

---

## ðŸ“¦ Installation & Usage

### 1. Prerequisites
- Node.js (v18+ recommended)

### 2. Install Dependencies
```bash
npm install
```

### 3. Run Development Server
```bash
npm run dev
```
